# Phantom Bridge Client - AI Coding Instructions

## Overview
**phntm_bridge** is a bidirectional WebRTC + Socket.io ROS2 bridge for real-time P2P teleoperation, HRI, and remote robot monitoring. It runs as a containerized ROS2 node that bridges robot topics/services to a remote web UI.

## Architecture

### Core Components
- **PhntmBridge (C++)**: Main ROS2 node managing introspection, service routing, and configuration
- **BridgeSocket**: Socket.io client connecting to TURN/signaling server at `bridge_server_address`
- **WRTCPeer**: Per-peer WebRTC connection handler managing topic subscriptions and data channels
- **Introspection**: Discovers and reports ROS2 topics, services, nodes, Docker containers via Socket.io
- **TopicReaderData/TopicReaderH264**: Subscribed to ROS2 topics, stream serialized messages over WebRTC data channels
- **TopicWriterData**: Writes ROS2 messages from WebRTC data channel inputs
- **FFmpegEncoder**: Hardware-accelerated H.264 encoding for sensor_msgs/Image and CompressedImage

### Data Flow
1. **Outbound**: ROS2 topic → TopicReader → WebRTC DataChannel → Browser UI
2. **Inbound**: Browser UI → WebRTC DataChannel → TopicWriter → ROS2 topic
3. **Control**: Web UI ↔ Socket.io → BridgeSocket → PhntmBridge (service calls, introspection)

### Communication Patterns
- **Socket.io**: Async control/introspection at `bridge_server_address`
- **WebRTC**: P2P binary data streaming (topics, services) via libdatachannel
- **ROS2 IPC**: Dynamic topic/service discovery; custom ROS2 message types via `extra_packages`

## Critical Workflows

### Build & Deploy
```bash
# Source ROS2 environment
source ~/.bashrc

# Colcon build (containerized in Docker)
cd /ros2_ws
colcon build --symlink-install --packages-select phntm_bridge

# Launch with GDB server (for debugging)
ros2 launch phntm_bridge client_launch.py use_gdb_server:=true
```

### Docker Development
- Container runs as privileged with `network_mode: host` (required for WebRTC + IPC)
- Config file: `phntm_bridge_params.yaml` (YAML ROS2 parameter format)
- Registry: `ghcr.io/phantomcybernetics/phntm_bridge_client` (pre-built images available)

### Configuration
- **Dynamic topic config** (QoS, reliability): per-topic under `/**:ros__parameters:/{topic_name}`
- **Media topics**: H.264 encoding config via `BridgeConfig::MediaTopicConfig` (hw_device, bitrate, gop_size)
- **Introspection**: controlled by `discovery_period_sec` (frequency) and `stop_discovery_after_sec`

## Key Patterns

### Service Type Support
- Uses **rosidl introspection** to dynamically resolve custom ROS2 service types
- `extra_packages` list can include local paths or apt package names (`ros-humble-pkg-name`)
- Services are dynamically loaded via `dlopen()` (library handle caching in `srv_library_handle_cache`)

### Message Serialization
- Binary serialized via **rosidl serialization** (not JSON)
- Includes `init_complete` handshake on DataChannel to ensure peer ready
- `TopicReaderData::Output` tracks per-peer state and logging flags to avoid spam

### Thread Safety
- Uses **multi-threaded executor** with reentrant callback groups (`introspection_reentrant_group`, `media_reentrant_group`)
- Mutexes protect service caches (`srv_init_mutex`, per-service client mutex)
- Global logger uses custom `phntm::log()` with ANSI color codes

### Hardware Integration
- **GPIO LEDs**: Control connection/data activity LEDs via libgpiodcxx
- **File extraction**: `FileExtractor` service retrieves files from running Docker containers
- **WiFi monitoring**: Integrates with system `wpa_supplicant` (via separate agent, not bridge)

## Common Tasks

### Adding Custom Message Type Support
1. Add ROS2 package to `extra_packages` in `phntm_bridge.yaml`
2. Topic will auto-discover; introspection reports message type to UI
3. For services: ensure `*_introspection` library is available (generated by colcon)

### Debugging WebRTC/Socket.io
- Enable logs: `log_sdp: True`, `log_heartbeat: True`, `webrtc_verbose: True` in config
- GDB server: `ros2 launch phntm_bridge client_launch.py use_gdb_server:=true`
- Check DataChannel state: `TopicReaderData::Output` init_complete and status flags

### Performance Optimization
- Increase `thread_count` in FFmpeg encoder for CPU-bound video encoding
- Use hardware encoding: `hw_device: vaapi` or `cuda` (must be available in container)
- Monitor `log_message_every_sec` (high values reduce logging overhead)

## Dependencies
- **ROS2 Humble+**: Core framework
- **libdatachannel**: WebRTC peer connections (custom fork with libnice)
- **FFmpeg**: Video encoding (libavformat, libavcodec, libswscale)
- **Socket.io C++ client**: Server connection + signaling
- **fmt, jsoncpp, yaml-cpp**: Utilities
- **OpenCV**: Image format conversions
- **gpiod, curl, tinyxml2**: GPIO, HTTP, XML parsing
